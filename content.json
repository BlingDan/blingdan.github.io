{"posts":[{"title":"Acwing 913.排队打水题解","text":"Acwing 913.排队打水 思路：可以得出当排队时间按升序打水，等待时间最短 数学证明：反证法 有n个人，对第i个和第i+1个打水的人，他们的打水时间为 $t_i$, $t_{i+1}$ ($t_i$ &lt; $t_{i+1}$) 若按升序打水时间$T_1$ = $t_i$ * (n - i) + $t_{i+1}$ * (n-i-1) 若两者顺序转换: $T_2$ = $t_{i+1}$ * (n - i) + $t_i$ * (n - i - 1) $T_1$ - $T_2$ = $t_i$ - $t_{i+1}$ &lt; 0 以此类推可知升序时间最小 c++代码12345678910111213141516171819202122232425262728293031323334/* * @Author: Awesome_ZC * @Date: 2021-08-29 15:22:21 * @Version: 1.0 */#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100010;int n;int a[N];int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); sort(a, a + n); LL ans = 0; for(int i = n -1, j = 0; i &gt;= 1; i --, j ++) ans += i * a[j]; cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2022/04/06/Acwing%20913.%E6%8E%92%E9%98%9F%E6%89%93%E6%B0%B4%E9%A2%98%E8%A7%A3/"},{"title":"Stories About C Plus Plus","text":"🧀 Knowing, learning and mastering c++ is a cool thing in my opinion. Like a chef with a handy kitchen knife, you can do a lot of interesting things with c++. This learning note is mainly about some c++ points. Wish myself an early glimpse of c++. staticthis指针inline12345678910111213141516171819//inline.h#ifndef BASE_INLINE_H#define BASE_INLINE_Hclass A{public: int foo1(int x, int y); void Foo(int x, int y) { }; void f1(int x);};#endif //BASE_INLINE_H 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &quot;inline.h&quot;using namespace std;int Foo(int x, int y);inline int Foo(int x, int y){ return x + y;}//定义处添加inline（显示声明）推荐inline void A::f1(int x){}int main(){ cout &lt;&lt; Foo(1,2) &lt;&lt; endl;} 声明方式inline 对编译器来说是一条指令而非命令，可以显示声明可以隐式声明。 显示声明：==inline==修饰符 123456int foo(int x, int y); //函数声明inline int foo(int x, int y) // 函数定义{ return x + y;} 隐式声明：类中方法的定义 12345class A{public: int foo1(int x, int y); //隐式声明} 使用场景首先了解编译器对inline的处理 将inline函数体复制到调用处 为inline函数中的局部变量分配内存空间 将inline函数的输入参数和返回值映射到调用方法的局部空间中 inline若有多个返回点将其转变为 inline 函数代码块末尾的分支（使用 GOTO） 内联函数能够提高函数效率，实质上就是将函数直接复制，一耗费更过空间为代价省去了函数调用的开销。提高函数执行效率。以下场景不适合使用 函数代码执行时间相比于函数调用花费时间长 函数代码段较长，函数体内出现循环。 虚函数的vptr与vtable 一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时 //todo assert 断言 断言是宏在&lt;assert.h&gt;头文件中，而非函数。 通过定义NDEBUG关闭assert，定义在源码开头，#include&lt;assert.h&gt;之前 为何使用/与正常错误处理 断言用于检查逻辑上不可能的情况如：检查源码在运行前期望的状态或者在运行完成后的检查状态 与正常错误处理不同断言通常在运行时被禁用 12345678910111213141516171819//#define NDEBUG 定义后assert不可用#include &lt;iostream&gt;#include &lt;assert.h&gt;using namespace std;int main(){ int x = 7; //some code x = 9; //some code assert(x==7); return 0;} extern”c” and extern “C++”extern 用于c++ 链接c语言中定义的函数 在编译阶段，c++编译生成的文件中可能有些符号与C语言生成的不同，比如c++中的重载，多态等。extern的作用便是：告诉链接器去寻找c语言符号而不是经过c++修饰后的符号 ``先看一个错误的例子 1234567891011121314151617181920212223242526272829//add.h#ifdef BASE_ADD_Hextern &quot;C&quot; {#endifint add(int x, int y);#ifdef BASE_ADD_H}#endif //BASE_ADD_H//add.c#include &lt;stdio.h&gt;#include &quot;add.h&quot;int add(int x, int y){ return x + y;}//add.cpp#include &lt;iostream&gt;using namespace std;extern &quot;C&quot;{#include &quot;add.h&quot;}int main(){ add(2,3); return 0;} error: ‘add’ was not declared in this scope 在stdio.h标准库中 123#ifdef __cplusplusextern &quot;C&quot; {#endif c++ 在调用接口时以C接口调用。这种写法使得c++在调用时不需要额外写externa “C” C与C++中struct的区别 C C++ 结构体中无函数 可有函数 无访问修饰符，默认public protect, private,public 定义的结构体变量，使用时必须加上 struct 可不加 无继承 可继承 若结构体的名字与函数名相同，可以正常运行且正常的调用 若结构体的名字与函数名相同，使用结构体，只能使用带struct定义 friend友元函数：可以理解为静态函数，需单独实现，能够访问类的私有和保护成员友元类： 同理见实例 特点破坏了封装性，提高了运行效率 一些性质 不可传递性: A是B的友元类，B是C的友元类，A不是C的友元类 无继承性： B是A的友元类，C继承A，C无法访问B的私有和保护成员 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;class A{public: A(int _a):a(_a){}; friend int geta(A a); friend class B; //B是A的友元类，private: int a;};int geta(A a){ return a.a;}class B{public: int getb(A _a){ return _a.a; }};int main(){ A a{2}; B b; cout &lt;&lt; &quot;geta:\\t&quot; &lt;&lt; geta(a) &lt;&lt;endl; cout &lt;&lt; &quot;getb:\\t&quot; &lt;&lt; b.getb(a) &lt;&lt; endl; return 0;} :: 作用域声明作用域 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的 123456789101112131415161718192021//From Light-City#include &lt;iostream&gt;using namespace std;int count=0; // 全局(::)的countclass A {public: static int count; // 类A的count (A::count)};// 静态变量必须在此处定义int A::count;int main() { ::count=1; // 设置全局的count为1 A::count=5; // 设置类A的count为2 cout&lt;&lt;A::count&lt;&lt;endl;// int count=3; // 局部count// count=4; // 设置局部的count为4 return 0;} ReferenceLight-City/CPlusPlusThings","link":"/2022/09/02/CPlusPlusThings%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"CommentDemo","text":"Test Comment plugin","link":"/2024/06/23/CommentDemo/"},{"title":"EOJ.3338.双塔问题","text":"题目来源3338. 双塔问题 思路占位 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110, M = 10010;int f[N][M];int a[N];int n, m;int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; m += a[i]; } memset(f, -0x3f, sizeof(f)); // 初始化为负无穷 f[0][0] = 0; // 状态转移 for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt;= m; j++) { // 不选择 f[i][j] = f[i - 1][j]; // 将第i块分配给较矮的塔 if (j &gt;= a[i]) f[i][j] = max(f[i][j], f[i - 1][j - a[i]] + a[i]); else f[i][j] = max(f[i][j], f[i - 1][a[i] - j] + j); // 将第i块分配给较高的塔 f[i][j] = max(f[i][j], f[i - 1][j + a[i]]); } } if(f[n][0] &lt;= 0) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; f[n][0] &lt;&lt; endl; return 0;}","link":"/2025/03/02/EOJ-3338-%E5%8F%8C%E5%A1%94%E9%97%AE%E9%A2%98/"},{"title":"EOJ刷题记录第七弹","text":"Problem #3744 - ECNU Online Judge题目描述一个$n × n$的与矩阵由一个长度为$n$的数列 $a₁, a₂, …, aₙ$ 生成。矩阵中第$i$行第$j$列的元素 $(i, j)$定义为 $aᵢ$与$aⱼ$的按位与运算结果，即$(i,j)$=aᵢ&amp;aⱼ。其中，&amp;表示按位与运算。对于同一个与矩阵，可能存在多个不同的数列可以生成它。现在：给定一个$n × n$的矩阵，你需要找到任意一个能够生成该矩阵的数列 $a₁, a₂, …, aₙ$。保证生成的字典序最小。 思路为了保证生成的字典序最小，应该使用贪心的思路即，先确定a[1]的最小值，让后确定a[2]以此类推。 以$a[1]$为例，$a[1]$的取值与$matrix[1][j]$有关，如果$matrix[1][j]$的第$k$位为1，那么$a[1]$中的第$k$位同样为1，找到满足所有$matrix[1][j]$为1的位并且求最小值 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//#include &lt;iostream&gt;//#include &lt;cstring&gt;//#include &lt;algorithm&gt;////using namespace std;////const int N = 1010;//int ans[N][32];//int g[N][N];////int main()//{// int n;// cin &gt;&gt; n;// for(int i = 0; i &lt; n; i ++)// for(int j = 0; j &lt; n; j ++)// cin &gt;&gt; g[i][j];//// for(int i = 0; i &lt; n; i ++)// for(int j = 0; j &lt; n; j ++)// {// if(g[i][j] != 0)// {// for(int k = 0; k &lt; 32; k ++)// {// if(g[i][j] &gt;&gt; k &amp; 1) {// ans[i][k] = 1;// ans[j][k] = 1;// }// }// }// }//// for(int i = 0; i &lt; n; i ++)// {// long long t = 0;// for(int j = 31; j &gt;= 0; j --)// t = t * 2 + ans[i][j];// cout &lt;&lt; t &lt;&lt; ' ';// }//// return 0;//}#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n)); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; n; ++j) { cin &gt;&gt; matrix[i][j]; } } vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; ++i) { a[i] = 0; // 初始化 a[i] for (int j = 0; j &lt; n; ++j) { if (i != j) { a[i] |= matrix[i][j]; // 按位或运算 } } } for (int i = 0; i &lt; n; ++i) { cout &lt;&lt; a[i] &lt;&lt; (i == n - 1 ? &quot;&quot; : &quot; &quot;); // 输出结果，注意最后一个数字后不要有空格 } cout &lt;&lt; endl; return 0;} Problem #180 - ECNU Online Judge思路在暴力枚举基础上使用二分 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 100000, M = 30;int a, n, m , x;int f[M]; // f[i] 第i站开出的人数int up[M]; // up[i] 第i站上车人数bool check(int x){ memset(f, 0, sizeof f); memset(up, 0, sizeof up); f[1] = a, f[2] = a, up[1] = a, up[2] = x; for(int i = 3; i &lt;= n - 1; i ++) { up[i] = up[i - 1] + up[i - 2]; f[i] = f[i - 1] + up[i - 2]; }// printf(&quot;x = %d f[n-1]=%d\\n&quot;, x, f[n - 1]); return f[n - 1] &gt;= m ? true:false;}int main(){ cin &gt;&gt; a &gt;&gt; n &gt;&gt; m &gt;&gt; x; // 枚举第2站上下车人数 int l = 0, r = N; while(l &lt; r) { int mid = l + r &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; } memset(f, 0, sizeof f); memset(up, 0, sizeof up); f[1] = a, f[2] = a, up[1] = a, up[2] = l; for(int i = 3; i &lt;= x; i ++) { up[i] = up[i - 1] + up[i - 2]; f[i] = f[i - 1] + up[i - 2]; } cout &lt;&lt; f[x] &lt;&lt; endl; return 0;} string中的细节字符串字典序的比较：string已重载了运算符直接使用 若是自定义字典序，注意 12345678string s1 = a.first; string s2 = b.first; for(int i = 0; i &lt; min(a.first.size(), b.first.size()); i ++) { if(s1[i] != s2[i]) // 不等于就返回，不是小于才返回 return s1[i] &lt; s2[i]; } return a.first.size() &lt; b.first.size();","link":"/2025/03/12/EOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%83%E5%BC%B9/"},{"title":"EOJ刷题记录&amp;题解第一弹","text":"2957. 统计不同的最简真分数的个数思路学习set迭代器的使用 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// Created by HUAWEI on 2025/3/6.//#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;const int N = 1010;set&lt;int&gt; a;int gcd(int a, int b){ if(b == 0) return a; else return gcd(b, a % b);}int main(){ int T; cin &gt;&gt; T; for(int count = 0; count &lt; T; count ++) { a.clear(); int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) { int num; cin &gt;&gt; num; a.insert(num); } int res = 0; for(auto i = a.begin(); i != a.end(); i ++) for(auto j = next(i); j != a.end(); j ++) { int k = *i, m = *j; if(k &lt; m &amp;&amp; gcd(k, m) == 1) res ++; } cout &lt;&lt; &quot;case #&quot; &lt;&lt; count &lt;&lt; &quot;:\\n&quot; &lt;&lt; res &lt;&lt; &quot;\\n&quot;; }} 2958. 求上升子序列和的最大值思路最长上升子序列dp问题，卡在了初始化上。 什么情况下一定有上升子序列？数本身构成的长度为1的子序列 代码123456789101112131415161718192021222324252627282930313233343536373839404142//// Created by HUAWEI on 2025/3/6.//#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5010;int a[N];int f[N];int n, T;int main(){ cin &gt;&gt; T; for(int count = 0; count &lt; T; count ++) { memset(a, 0, sizeof a); memset(f, 0, sizeof f); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i ++) f[i] = a[i]; for(int i = 2; i &lt;= n; i ++) for(int j = 1; j &lt; i; j ++) { if(a[j] &lt; a[i]) f[i] = max(f[i], f[j] + a[i]); } int ans = -1; for(int i = 1; i &lt;= n; i ++) ans = max(ans, f[i]); printf(&quot;case #%d:\\n%d\\n&quot;, count, ans); } return 0;} 3035. 次大黑区域思路经典的dfs问题，遍历到的点就记录下来不需要回溯。 最终的结果使用set存储，不用再考虑去重问题。输出次大值使用auto it = next(area.begin())，其中it是一个迭代器(iterator),使用 set 的 begin()、end()、next() 等方法获取迭代器时，这些迭代器是指向 set 中元素的指针。 这意味着 it 变量存储的是 指向 集合中某个元素的指针，而不是元素本身的值 。所以输出指针的值使用解引用*，表明取 it 指向的内存地址上的值 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// Created by HUAWEI on 2025/3/6.//#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;set&gt;using namespace std;const int N = 110;int g[N][N];bool st[N][N];set&lt;int, greater&lt;int&gt;&gt; area;int n, m;int t; // 每个黑区域的大小int dx[4] = {0, 0, -1, 1};int dy[4] = {1, -1, 0, 0};void dfs(int a, int b){ if(st[a][b] || g[a][b] == 0) return; t ++; st[a][b] = true; for(int i = 0; i &lt; 4; i ++) { int x = a + dx[i], y = b + dy[i]; if(x &gt;= 1 &amp;&amp; x &lt;&lt; n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m &amp;&amp; !st[x][y] &amp;&amp; g[a][b] == 1) dfs(x, y); } return;}int main(){ int T; cin &gt;&gt; T; for(int cnt = 0; cnt &lt; T; cnt ++) { memset(g, 0, sizeof g); memset(st, 0, sizeof st); area.clear(); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) cin &gt;&gt; g[i][j]; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) { t = 0; dfs(i, j); area.insert(t); } auto it = next(area.begin()); printf(&quot;case #%d:\\n%d\\n&quot;, cnt, *it); } return 0;} 5124. 选择思路脑筋急转弯问题，思考了一会。没有认真读题看成了每次要选择下标连续的集合错误的认为至少需要n / 2次。查看未通过测试样例发现n为一个很大的数，Output为20。回看题干发现是求二进制位数。 代码1234567891011121314151617181920212223//// Created by HUAWEI on 2025/3/6.//#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n; cin &gt;&gt; n; int cnt = 0; while(n &gt; 0) { n = n &gt;&gt; 1; cnt ++; } cout &lt;&lt; cnt &lt;&lt; endl; return 0;}","link":"/2025/03/06/EOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E5%BC%B9/"},{"title":"EOJ刷题记录&amp;题解第三弹","text":"Problem #3299 - ECNU Online Judge这道题理解题意花了很长时间，靠着AI辅助才大致写完框架，测试debug了半个小时，发现是错在判断条件if (res[cur] == m_cnt &amp;&amp; m_c &gt; cur) m_c = cur。 题目意思是遍历所有的区间，一开始考虑$dp$但是 这不是常见的求最值问题 区间如果用$dp[i][j]$表示的话无法转化成子问题 因此考虑直接模拟遍历所有区间，时间复杂度$log(n^2)$满足条件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// Created by HUAWEI on 2025/3/8.//#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 5010;int color[N];int main(){ int n; while(cin &gt;&gt; n) { vector&lt;int&gt; ans(n + 10, 0); // 每种颜色为主色调的区间个数 memset(color, 0, sizeof color); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; color[i]; for (int i = 1; i &lt;= n; i++) { vector&lt;int&gt; res(n + 10, 0); int m_c = -1; // 维护的最大值颜色 int m_cnt = 0; // 最大值出现的次数 for (int j = i; j &lt;= n; j++) { int cur = color[j]; res[cur]++; if (res[cur] &gt; m_cnt) { m_cnt = res[cur]; m_c = cur; } else if (res[cur] == m_cnt &amp;&amp; m_c &gt; cur) { m_c = cur; } if(m_c &gt;= 1 &amp;&amp; m_c &lt;= n) ans[m_c]++; } } for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; ans[i]; if(i != n) cout &lt;&lt; ' '; else cout &lt;&lt; endl; } } return 0;}","link":"/2025/03/08/EOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%89%E5%BC%B9/"},{"title":"EOJ刷题记录第九弹","text":"Problem #3022 - ECNU Online Judge没想到是分解质因数的问题 Problem #1009 - ECNU Online Judge看作完全背包问题: 任何一个数可以选择无数次，最终让容积位n的方案数","link":"/2025/03/14/EOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B9%9D%E5%BC%B9/"},{"title":"EOJ刷题记录&amp;题解第二弹","text":"Problem #1163 - ECNU Online Judge尝试使用了EOJ 双塔问题的思路进行DP，质量可以类比塔的高度，然而忽略了双塔问题中要求让两个塔高度相同时候求高度的最大值，本题中二者质量可能不同。 思路对比 传统的０／１背包问题：给定物品的重量和价值，一个有限制的背包，目标是让背包中装入物品价值总和最大 本题（饼干分配问题）：给定两个背包，没有明确限制，要求最后分组让两个背包差值最小 联系 饼干对应背包中的物品，饼干质量对应物品重量。虽然没有给出背包的容积但可以任务让每个背包中重量接近总重量的一半。 定义$dp[i][j]$前$i$个物品放入质量为$j$ 的背包的最大重量（本题中$j$为总质量的一般） 状态转移方程$dp[i][j]=dp[i-1][j]$(不选第$i$个饼干) or $dp[i][j]=dp[i-1][j-w[i]]+w[i]$(选择第$i$个饼干) 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10, M = 30;int w[M];int f[M][N];int n, m;int main(){ while(cin &gt;&gt; n) { memset(f, 0, sizeof f); m = 0; for(int i = 1; i &lt;= n; i ++) { scanf(&quot;%d&quot;, &amp;w[i]); m += w[i]; } for(int i = 1; i &lt;= n; i ++) for(int j = 0; j &lt;= m / 2; j ++) { f[i][j] = f[i - 1][j]; if(j &gt;= w[i]) f[i][j] = max(f[i][j], f[i - 1][j - w[i]] + w[i]); } int ans = m - 2 * f[n][m / 2]; cout &lt;&lt; ans &lt;&lt; endl; } return 0;} Problem #3034 - ECNU Online Judge思路一道数学公式推到。设$f(n)为n的不同拆分方案数$，有递推式$$f(2m + 1) = f(2m),f(2m) = f(2m - 1) + f(m)$$ 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;const int N = 10010;int is_firm(int num, int div){ if(num &lt; div) return num; else if(num % div == 0) return 0; else return is_firm(num - num / div, div + 1);}int main(){ int T; cin &gt;&gt; T; for(int q = 0; q &lt; T; q ++) { int n; cin &gt;&gt; n; printf(&quot;case #%d:\\n&quot;, q); int pos = is_firm(n, 2); if(pos) cout &lt;&lt; &quot;Yes &quot; &lt;&lt; pos &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; } return 0;} Problem #3032 - ECNU Online Judge思路在板子上模拟后发现第$i$轮之后数组中的前$i$个数字都是安全的，换句话说不会在之后被筛掉。开一个$st[N]$数组来记录哪些数字已经被筛掉。这会有两个问题 时间复杂度过高 边界情况考虑不全 在评论区翻到一位大佬的回答豁然开朗，使用了类似dfs的思想，太天才了。 代码详见评论区 Problem #3507 - ECNU Online Judge思路占位，只考虑了贪心问题，没考虑dp 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int f[N]; //购买i张船票需要的最少纸币数量int n, k, p;int m[6] = {100, 50, 20,10, 5, 1};// 贪心，需要的纸币数量,X：金额int get_max_ticket(int x){ int res = 0; for(int i = 0; i &lt; 6; i ++) { if(x == 0) break; if(x &lt; m[i]) continue; res += x / m[i]; x %= m[i]; } return res;}//int main()//{// cin &gt;&gt; n &gt;&gt; k &gt;&gt; p;//// int ans = 0;// cout &lt;&lt; (n / k) * get_max_ticket(k * p) &lt;&lt; endl;// cout &lt;&lt; get_max_ticket((n % k) * p) &lt;&lt; endl;//// ans = (n / k) * get_max_ticket(k * p) + get_max_ticket((n % k) * p);//// cout &lt;&lt; ans &lt;&lt; endl;//// return 0;//}int main(){ memset(f, 0x3f, sizeof f); cin &gt;&gt; n &gt;&gt; k &gt;&gt; p; f[0] = 0; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= i &amp;&amp; j &lt;= k; j ++) { f[i] = min(f[i], f[i - j] + get_max_ticket(j * p)); } cout &lt;&lt; f[n] &lt;&lt; endl; return 0;} Problem #2877 - ECNU Online Judge占位，线性筛+二分???","link":"/2025/03/07/EOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%BA%8C%E5%BC%B9/"},{"title":"EOJ刷题记录第五弹","text":"Problem #3651 - ECNU Online Judge这是一个$dp$问题吗，也许是但是没想到类似的题，并且如果$dp$的话看$N，A，B$的大小发现是规模很大$10^9$,$dp$一般没那么大 题目中求的是和的个数，不是具体的怎么排列，从数学角度考虑两个极端的情况 BBB…BA AAA…AB 这两种情况分别对应着最大和最小两种情况，不管怎么取和一定在这两个范围之内，$MAX&lt;=Sum&lt;=MIN$，这也就对应了题干中所说求和的个数而不是具体排列。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;int main(){ int n, a, b; cin &gt;&gt;n &gt;&gt;a &gt;&gt; b; LL max1 = 1LL * (n - 1) *b + a; LL min1 = 1LL * (n - 1) *a + b; cout &lt;&lt; max1 - min1 +1 &lt;&lt; endl;} Problem #3306 - ECNU Online JudgeECNU 3306. 有钱人买钻石 （贪心+dfs） 为什么对任意面值的硬币贪心都要在[high， high - 25]之间?","link":"/2025/03/10/EOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%BA%94%E5%BC%B9/"},{"title":"EOJ刷题记录第八弹","text":"Problem #2846 - ECNU Online Judge思路从$dp$或者$dfs$角度考虑，$dp$比较困难，索性直接从$dfs$角度来写。调试的时候遇到了一个问题，if(fir != 1 &amp;&amp; sec != 0)这个判断条件的作用范围是什么？我觉得直观的感受是如果第一位不为1并且第二位不为0（即10*）的情况下，下一位只能填1。在debug时候死活有一些情况被莫名其妙的剪枝掉，才考虑判断条件问题：如果前缀是00会怎么样？true&amp;&amp;false=false，会被剪枝，在数学符号上成立但在判断条件中就错了，最后改成更加直观，注重于整体的判断条件：if(!(fir == 1 &amp;&amp; sec == 0)) 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n;int ans;// idx 当前下标，fir:上上一个位置，sec:上一个位置void dfs(int idx, int fir, int sec){ if(idx == n) {// cout &lt;&lt; &quot;output:&quot; &lt;&lt; fir &lt;&lt; ' ' &lt;&lt; sec &lt;&lt;endl; ans ++; return; }// if(fir != 1 &amp;&amp; sec != 0) if(!(fir == 1 &amp;&amp; sec == 0)) dfs(idx + 1, sec, 1); dfs(idx + 1, sec, 0);}int main(){ while(cin &gt;&gt; n) { if(n == -1) break; ans = 0; dfs(0, -1, -1); cout &lt;&lt; ans &lt;&lt; endl; } return 0;}","link":"/2025/03/13/EOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AC%AC%E5%85%AB%E5%BC%B9/"},{"title":"EOJ刷题记录第六弹","text":"unordered_map中count()与[]的区别unordered_map 的 count(key) 方法的目的是 专门用来检查键 key 是否存在于 map 中。 1. unordered_map 的 [] 运算符的行为 在 C++ 的 unordered_map 中，当你使用 [] 运算符访问一个键（例如 pos[remain]）时，会发生以下情况： 如果键 remain 已经存在于 pos 中： pos[remain] 会返回对 已存在的值 的引用（reference）。你可以读取或修改这个已存在的值。 如果键 remain 不存在于 pos 中： pos[remain] 会在 pos 中 插入一个新的键值对。 键是 remain。 值是该值类型的 默认值。对于 int 类型，默认值是 0。 pos[remain] 最终会返回对这个 新插入的默认值 0 的引用。 if (pos[remain] != 0) 的问题 当你使用 if (pos[remain] != 0) 时，你的意图是检查 “余数 remain 是否已经出现过（即是否在 pos 中有记录）”。 但是，由于 pos[remain] 的行为，这个判断会产生误导： 情况一：remain 已经出现过，并且在 pos 中有记录，假设记录的位置不是 0 (虽然我们的代码中位置 idx 从 0 开始，但这里为了普遍性假设位置值可以是任何非负整数)。 此时 pos[remain] 返回的是之前记录的位置值 (非零值)，所以 if (pos[remain] != 0) **条件为真 (true)**，这似乎是正确的，因为余数确实出现过了。 情况二：remain 第一次出现，之前没有在 pos 中记录。 此时 pos[remain] 会 插入新的键 remain，并赋值为默认值 0，然后返回对这个 0 值的引用。 因此， if (pos[remain] != 0) **条件为假 (false)**，这 也是正确的，因为余数是第一次出现。 情况三：remain 第一次出现，但是 pos 中 *已经存在* 键 remain，并且其对应的值 *恰好是 0* (这种情况在你的代码逻辑中其实不应该发生，因为一旦余数出现过，我们就会记录它的位置 idx，idx 是递增的，除非循环节起始位置恰好是 0，但那也是一个有效的位置，不应该被误判)。 这种情况比较微妙，但在你的代码逻辑中，如果循环节的起始位置恰好是索引 0， 并且你之前错误地使用了 if(pos[remain] != 0)， 可能会导致逻辑错误，虽然在这个特定问题中不太容易直接体现出来，但这是一个潜在的隐患。 更严重的问题 (隐藏的副作用): 即使在某些情况下 if (pos[remain] != 0) 看起来好像能工作，但 最根本的问题是 pos[remain] 会在你 *检查* 的同时 *修改* pos 本身 (如果键不存在时会插入默认值)。 这是一种 副作用，使得你的代码逻辑变得不清晰和难以维护。你本意只是想 判断是否存在，结果却意外地 修改了数据结构。 Problem #2896 - ECNU Online Judge读取一行字符串（包括空格）应该怎么处理 getchar()是读取一个字符，getline()读取的已经包含’\\n’ getline(cin, str) 读取一行 istringstream 一个变量(str); 构造istringstream while(一个变量 &gt;&gt; string); istringstream类用空格划分读入到string Problem #1018 - ECNU Online Judgestring 常用技巧截断子串 12string tmp = tar;tmp.replace(tar.find(it), it.size(), &quot;&quot;); CodeBlocks设置代码补全setting-&gt;editor-&gt;Code completion Keyword sets to additionally include1~9全部勾中 延迟200ms","link":"/2025/03/11/EOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AC%AC%E5%85%AD%E5%BC%B9/"},{"title":"EOJ刷题记录第十弹","text":"F - 借仙书 EOlymp - 2524题目Goran希望在仙界图书馆借一本书。这本书在仙界图书馆分为了两版发行，分别是a版和b版。这本书非常热门，图书馆的存量也非常大，并且摆放时也有规律：第0号书柜放的是a版，第1号书柜放的是b版，对于第k(k&gt;1)个柜子，书的摆放方式就是重复将它前边两个书柜的排放方式，例如前几个书柜的顺序为:a,b,ab,bab,abbab,bababbab,abbabbababbab,…当Goran在第N号书柜中选择其中的第k本书时，请你帮他判断这本书究竟是a版还是b版。（书柜从0开始编号，书柜中的书从1开始编号） 数据输入第1行一个整数T，表示接下来Goran要选T次书。接下来有T行，每行2个由空格分隔的整数N,K,表示Goran在第N号书柜选择第K本书 1≤T≤1001≤N≤50k不超过当前书柜中书的数量，并且k≥1 数据输出输出有T行，每行输出字符a或b，表示对于Goran每次选的书，这本书是a版还是b版 样例输入样例40 11 13 27 7输出样例abaa 思路一开始尝试直接将所有字符串存下来后直接查找，发现程序运行没反应。当测试了斐波那契fib[50]，是一个$10^{10}$级别的数，需要long long。如果直接存string显然会溢出。 于是思考下能不能直接用$dp[i][j]$来表示第i个的第$k$个是什么，这样思考的话$k$是个很大的值，也不成。 由此想到直接找数学规律，斐波那契数列。传入$n, k$。讨论第$k$位是属于$f[n - 2]$ 还是$f[n - 1]$。 常用的斐波那契函数忘记直接return结果，导致结果错了，注意注意！！ 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 50;LL f[N];char fib(int n, int k){ if(n == 0) return 'a'; if(n == 1) return 'b'; if(k &lt;= f[n - 2]) return fib(n - 2, k); else return fib(n - 1, k - f[n - 2]);}int main(){ f[0] = 1, f[1] = 1; for(int i = 2; i &lt; N; i ++) f[i] = f[i - 1] + f[i - 2]; int T; cin &gt;&gt; T; while(T --) { int n, k; cin &gt;&gt; n &gt;&gt; k; cout &lt;&lt; fib(n, k) &lt;&lt; endl; }}","link":"/2025/03/21/EOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AC%AC%E5%8D%81%E5%BC%B9/"},{"title":"EOJ刷题记录第四弹","text":"Problem #3369 - ECNU Online Judge注意边数，意识到了使用邻接表，但是边数是二倍忘记考虑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 1010;int e[2 * N], ne[2 * N], h[N], idx;int n;int u, v;long long ans;void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx ++;}void dfs(int root, int fa, int res){ if(res &gt;= 4) { ans ++; return; } for(int i = h[root]; i != -1; i = ne[i]) { int j = e[i]; if(j != fa) dfs(j, root, res + 1); }}int main(){ memset(h, -1, sizeof h); cin &gt;&gt; n; for(int i = 1; i &lt;= n - 1; i ++) { cin &gt;&gt; u &gt;&gt; v; add(u, v); add(v, u); } for(int i = 1; i &lt;= n; i ++) dfs(i, -1, 1); cout &lt;&lt; ans / 2 &lt;&lt; endl; return 0;} Problem #3367 - ECNU Online Judge第一眼是前缀和-差分数组问题，维护一个数组chazhi[N]，定义为0-1的个数。 1234567891011121314151617181920212223242526272829303132333435// 错误思路，TLE#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int sum0[N];int sum1[N];int n;int main(){ cin &gt;&gt; n; int t; for(int i = 1; i &lt;= n; i ++) { cin &gt;&gt; t; sum1[i] = sum1[i - 1]; sum0[i] = sum0[i - 1]; if(t == 1) sum1[i] ++; else sum0[i] ++; } int ans = 0; for(int i = 1; i &lt;= n; i ++) for(int j = i; j &lt;= n; j ++) ans = max(ans, sum0[j] - sum0[i - 1] - (sum1[j] - sum1[i - 1])); cout &lt;&lt; ans + sum1[n] &lt;&lt; endl; return 0;} 最大子数组和 有一个非常经典的 O(n) 算法，叫做 Kadane’s Algorithm ( Kadane算法 ) Kadane 算法要解决什么问题？ （很明显，就是最大子数组和问题） Kadane 算法的核心思想是什么？ （动态规划？贪心？ 仔细体会它的递推关系） Kadane 算法的时间复杂度是多少？ （O(n)，非常高效） 如何用代码实现 Kadane 算法？ （C/C++ 代码并不复杂） 学习 Kadane 算法之后，你就会发现，它可以非常漂亮地解决我们当前的问题。 只需要把原始数组转换成 [1, -1, -1, 1, 1, 1, …] 这种形式，然后用 Kadane 算法求最大子数组和，再加上原始数组中 1 的数量，就是最终答案！ 3. 算法步骤 (Step-by-Step Logic) 假设输入数组为 arr，长度为 n。 初始化： global_maximum = arr[0] (或者负无穷，如果数组可能全为负数) current_maximum = arr[0] (或者 0，如果允许空子数组，但本题要求至少翻转一条咸鱼，所以子数组不能为空，这里初始化为第一个元素更合适) 迭代数组 (从第二个元素开始，索引从 1 到 n-1)： 对于每个元素 arr[i]： current_maximum = max(arr[i], current_maximum + arr[i]) // 关键步骤：更新 current_maximum global_maximum = max(global_maximum, current_maximum) // 更新 global_maximum 返回 global_maximum 推荐题目列表: 题目名称: 最大子矩阵和 (Maximum Submatrix Sum) 简要描述: 给定一个二维矩阵，找到一个子矩阵，使其元素之和最大。 解题思路提示: 可以将二维问题降维到一维，枚举子矩阵的上下边界，然后将每一列的子矩阵部分求和，转化为一维的最大子数组和问题。 可以使用 Kadane’s Algorithm 解决一维子问题。 预期学习效果: 掌握将一维 DP 思想扩展到二维问题的技巧，加深对 Kadane’s Algorithm 的理解。 题目名称: 环形子数组最大和 (Maximum Sum Circular Subarray) 简要描述: 给定一个环形数组，找到一个子数组，使其元素之和最大。环形数组意味着数组的最后一个元素和第一个元素是相邻的。 解题思路提示: 环形数组的最大子数组和，要么是普通子数组的最大和 (不跨越环形边界)，要么是跨越环形边界的子数组和。 可以分别计算这两种情况，取最大值。 跨越环形边界的子数组和，可以转换为 数组总和 减去 最小子数组和。 预期学习效果: 学习如何处理环形数组问题，掌握将问题分解为不同情况进行讨论的技巧。 题目名称: 乘积最大子数组 (Maximum Product Subarray) 简要描述: 给定一个整数数组，找到一个非空的连续子数组，使其乘积最大。 解题思路提示: 与最大子数组和类似，但需要同时维护最大值和最小值。 因为负数的存在，最小值乘以负数可能变成最大值。 状态转移时需要考虑当前元素、之前的最大值和最小值。 预期学习效果: 学习如何处理乘积最大化问题，理解负数对最大值的影响，扩展动态规划的应用场景。 用DP考虑 步骤 状态怎么表示 状态怎么转移 dp数组怎么初始化","link":"/2025/03/09/EOJ%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AC%AC%E5%9B%9B%E5%BC%B9/"},{"title":"Hexo+Icarus+Github Page配置","text":"Hexo博客搭建网络上参考资料很多这里略过 Github Actions部署 Hexo博客建立私有化仓库私有化仓库来存放自己的博客，New-&gt;Repository Name-&gt;private-&gt;create repository 创建Github Token创建token-&gt;Generate new token-&gt;Generate new token(classic)-&gt;具体配置看下图-&gt;记住生成的token 设置workflow在本地blog根目录下创建*.github\\workflows\\hexo-deploy.yml*文件，具体代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455name: 自动部署on: push: branches: - master release: types: - publishedjobs: deploy: runs-on: ubuntu-latest steps: - name: 检查分支 uses: actions/checkout@v3 with: ref: master - name: 安装 Node uses: actions/setup-node@v3 with: node-version: &quot;20.x&quot; - name: 安装 Hexo 和 theme主题 run: | export TZ='Asia/Shanghai' npm install hexo-cli -g - name: 缓存 Hexo uses: actions/cache@v3 id: cache with: path: node_modules key: ${{runner.OS}}-${{hashFiles('**/package-lock.json')}} - name: 安装依赖 if: steps.cache.outputs.cache-hit != 'true' run: | npm install --save - name: 生成静态文件 run: | hexo clean hexo generate - name: 部署 #此处master:master 指从本地的master分支提交到远程仓库的master分支(不是博客的分支写master即可)，若远程仓库没有对应分支则新建一个。如有其他需要，可以根据自己的需求更改。 run: | cd ./public git init git config --global user.name '${{ secrets.GITHUBUSERNAME }}' git config --global user.email '${{ secrets.GITHUBEMAIL }}' git add . git commit -m &quot;${{ github.event.head_commit.message }} $(date +&quot;%Z %Y-%m-%d %A %H:%M:%S&quot;) Updated By Github Actions&quot; git push --force --quiet &quot;https://${{ secrets.GITHUBUSERNAME }}:${{ secrets.GITHUBTOKEN }}@github.com/${{ secrets.GITHUBUSERNAME }}/${{ secrets.GITHUBUSERNAME }}.github.io.git&quot; master:master # GitHub配置 上传代码到私有仓库1234git checkout master #确保转到本地master分支git add .git commit -m 'your message'git push origin master # 将本地master推送到远程仓库 最后，查看私有仓库中的Action运行情况，运行完成之后将内容推送到github.io的master分支中 个性化配置文章目录在_config.icarus.yml中添加挂件配置 123456widgets: - type: toc position: left # 是否显示目录项目的序号 index: true 在需要开启目录的文章头部加入toc: true 1234title: 一篇有目录的文章toc: true---文章内容... 进一步，在hexo模板中修改文章的模板scaffolds/post.md，这样每次hexo new ***就会根据模板创建 12345678---title: {{ title }}date: {{ date }}tags:excerpt: 文章摘要toc: true #目录--- 修改布局宽度页面宽度编辑&lt;icarus_directory&gt;/include/style/responsive.styl 123456789+widescreen() .is-1-column .container, .is-2-column .container max-width: $desktop - 0 * $gap width: $desktop - 0 * $gap+fullhd() .is-2-column .container max-width: $widescreen - 0 * $gap width: $widescreen - 0 * $gap 挂件或主内容宽度参考常见问题 自定义字体默认的CDN服务提供商配置： 1234providers: cdn: jsdelivr fontcdn: google iconcdn: fontawesome 在修改字体时，我选择直接到Google Fonts中查找。 如我想使用Noto Sans Simplified Chinese和PT Serif字体，在Google Font添加选中两种字体，点击get embaded code后根据html代码修改即可 修改/icarus/layout/common/head.jsx 12345const fontCssUrl = { // default: fontcdn('Ubuntu:wght@400;600&amp;family=Source+Code+Pro', 'css2'), default: fontcdn('PT+Serif:wght@400;700&amp;Noto+Sans+SC:wght@100..900', 'css2'), cyberpunk: fontcdn('Oxanium:wght@300;400;600&amp;family=Roboto+Mono', 'css2') }; 修改/icarus/include/style/base.styl 1$family-sans-serif ?= 'PT Serif', 'Noto Sans SC', sans-serif 文章metadata格式修改Github Discussion1304 Reference Icarus官方文档 Hexo博客搭建之Icarus主题–个性化修改篇 icarus个性化配置 Github+Hexo+icarus创建自定义blog 字体识别 leimao How can I change font? #713","link":"/2024/06/21/Hexo+Icarus+Github%20Page%E9%85%8D%E7%BD%AE/"},{"title":"从零开始的Python学习","text":"+ HTML 标签&lt;a&gt; 标签 (Anchor Tag) 标签用于定义超链接（hyperlink），允许用户从一个网页跳转到另一个网页、同一页面的不同位置、文件下载地址、电子邮件地址等。 主要属性： href (Hypertext Reference): 用于指定链接的目标 URL 或锚点。 外部链接: href=&quot;https://www.example.com&quot; 内部链接 (同一网站的不同页面): href=&quot;/about.html&quot; 或 href=&quot;about.html&quot; (取决于文件路径) 锚点链接 (同一页面的不同部分): href=&quot;#section2&quot; (需要配合页面中具有 id=&quot;section2&quot; 的元素使用) 电子邮件链接: href=&quot;mailto:user@example.com&quot; 电话链接: href=&quot;tel:+1234567890&quot; JavaScript 代码 (不推荐直接在 href 中使用): href=&quot;javascript:alert('Hello!')&quot; (通常更好的做法是使用事件监听器) target: 指定在何处打开链接的文档。 _blank: 在一个新的窗口或标签页中打开链接。 _self: 在当前窗口或标签页中打开链接 (默认值)。 _parent: 在父框架中打开链接。 _top: 在最顶层的框架集中打开链接。 &lt;framename&gt;: 在指定的框架中打开链接。 rel (Relationship): 描述当前文档与被链接文档之间的关系。常用的值包括： noopener: 防止新标签页中的网站访问你的窗口对象 (window.opener)，提高安全性。通常与 target=&quot;_blank&quot; 一起使用。 noreferrer: 阻止浏览器在 HTTP 请求头中发送 Referer 信息。通常与 target=&quot;_blank&quot; 一起使用。 nofollow: 告诉搜索引擎不要将链接权重传递给目标页面，常用于评论或用户生成的内容中的链接。 download: 提示浏览器下载链接的资源，而不是导航到它。可以指定下载的文件名，例如 download=&quot;my-document.pdf&quot;。 type: 指定链接文档的 MIME 类型，例如 type=&quot;application/pdf&quot;。 用法示例： HTML 12345&lt;a href=&quot;https://www.google.com&quot; target=&quot;_blank&quot;&gt;访问 Google&lt;/a&gt;&lt;a href=&quot;/products/details.html&quot;&gt;查看产品详情&lt;/a&gt;&lt;a href=&quot;#contact&quot;&gt;跳转到联系我们部分&lt;/a&gt;&lt;a href=&quot;mailto:info@example.com&quot;&gt;发送邮件给我们&lt;/a&gt;&lt;a href=&quot;document.pdf&quot; download=&quot;report.pdf&quot;&gt;下载报告&lt;/a&gt; &lt;span&gt; 标签&lt;span&gt; 标签是一个内联容器，用于在文本中标记一小段内容，以便可以使用 CSS 或 JavaScript 对其进行样式化或操作。&lt;span&gt; 标签本身没有任何语义上的含义，它只是一个通用的行内元素。 主要特点： 内联元素: &lt;span&gt; 元素默认是内联的，这意味着它不会打断正常的文本流，并且只占据它包含的内容所需的宽度。 无语义: 它本身不表示任何特定的内容类型或结构。 通常与 CSS 和 JavaScript 配合使用: 通过为 &lt;span&gt; 元素添加 class 或 id 属性，可以方便地使用 CSS 来设置样式，或者使用 JavaScript 来进行动态操作。 用法示例： HTML 123456789101112131415161718&lt;p&gt;这是一段包含 &lt;span style=&quot;color: red;&quot;&gt;红色&lt;/span&gt; 文字的段落。&lt;/p&gt;&lt;p&gt;请注意 &lt;span class=&quot;important&quot;&gt;重要&lt;/span&gt; 事项。&lt;/p&gt;&lt;script&gt; const importantSpans = document.querySelectorAll('.important'); importantSpans.forEach(span =&gt; { span.addEventListener('click', () =&gt; { alert('你点击了一个重要事项！'); }); });&lt;/script&gt;&lt;style&gt; .important { font-weight: bold; background-color: yellow; }&lt;/style&gt; &lt;img&gt; 标签 (Image Tag) 标签用于在 HTML 文档中嵌入图像。它是一个自闭合标签，意味着它没有闭合标签 ()。 主要属性： src (Source): 这是 标签最主要的属性，用于指定图像文件的路径 (URL)。可以是相对路径或绝对路径。 相对路径: src=&quot;images/logo.png&quot; (假设 images 文件夹与当前 HTML 文件在同一目录下) 绝对路径: src=&quot;https://www.example.com/images/banner.jpg&quot; alt (Alternative Text): 提供图像的替代文本描述。当图像无法加载时，或者对于屏幕阅读器等辅助技术，alt 属性的内容会被显示或朗读。这是一个非常重要的属性，有助于网站的可访问性和 SEO。 width 和 height: 指定图像的宽度和高度 (以像素为单位)。建议设置这两个属性，以防止页面在图像加载时发生布局跳动。 loading: 控制图像的加载方式，可以提高页面性能。 lazy: 延迟加载图像，直到它们接近视口时才加载。 eager: 立即加载图像 (默认值)。 srcset: 允许为不同的屏幕尺寸或设备像素比率提供不同的图像版本，实现响应式图像。 sizes: 与 srcset 属性一起使用，定义在不同的屏幕条件下图像的预期宽度。 crossorigin: 用于处理跨域图像的加载。 用法示例： HTML 123&lt;img src=&quot;logo.png&quot; alt=&quot;公司的标志&quot; width=&quot;150&quot; height=&quot;50&quot;&gt;&lt;img src=&quot;banner-large.jpg&quot; srcset=&quot;banner-small.jpg 480w, banner-medium.jpg 800w, banner-large.jpg 1200w&quot; sizes=&quot;(max-width: 600px) 480px, (max-width: 992px) 800px, 1200px&quot; alt=&quot;一个漂亮的横幅&quot;&gt;&lt;img src=&quot;lazy-image.jpg&quot; alt=&quot;延迟加载的图片&quot; loading=&quot;lazy&quot;&gt; 总结： &lt;a&gt; 用于创建超链接，实现页面间的跳转或与外部资源的连接。 &lt;span&gt; 是一个无语义的内联容器，常用于配合 CSS 和 JavaScript 对文本进行样式化或操作。 &lt;img&gt; 用于在 HTML 文档中嵌入图像，并提供了描述、尺寸和加载控制等属性。 yield关键字yield关键字的引入是为了实现生成器generator，生成器是一种特殊类型的函数，以更简洁，更节省内存的方式来生成一个序列，不需要一次性将所有的值都存储在内存中（和return类比） 推导式常用来生成字典，列表，序列等 123456789# 列表推导式mylist = [str(i) + j for i in range(1, 3) for j in 'ABC'] # ['1A', '1B', '1C', '2A', '2B', '2C']# 字典转化成列表mydict = {'key1': 'value1', 'key2': 'value2'} # ['key1:value1', 'key2:value2']mylist2 = [key + ':' + value for key, value in mydict.items()]# 推导式生成字典mydict = {i: i**2 for i in range(1, 10)} PyMySQL 进行数据库操作Scrapy框架 scrapy-readthedocs 组件 对应爬虫三大流程 Scrapy 项目是否需要修改 引擎 大脑 无需修改，框架已写好 调度器 接受engine的请求，按照先后顺序压入队列中，去除重复请求 无需修改，框架已写好 下载器 获取网页 (request 库) 无需修改，框架已写好 爬虫器 解析网页 (BeautifulSoup 库) 需要 管道 存储数据 (存入 csv/txt/MySQL 等) 需要 下载器中间件 获取网页 - 个性化部分 一般不用 爬虫器中间件 解析网页 - 个性化部分 一般不用 安装和使用1234pip install scrapyscrapy startproject yourprojectnamescrapy crawl name 简单的案例movies.py12345678910111213141516171819202122232425262728293031323334353637383940# 这里同样引用了scrapy中的pipline midedlewares等import scrapyfrom bs4 import BeautifulSoupfrom spiders.items import DouBanMovieItem class MoviesSpider(scrapy.Spider): name = &quot;movies&quot; # 爬虫名称 运行时候很重要 allowed_domains = [&quot;movie.douban.com&quot;] # 允许爬取的域名，防止无限爬取 start_urls = [&quot;https://movie.douban.com/top250&quot;] # 第一次发起的请求，获取一部分头部信息等 # 注释默认的parse方法，重写parse方法 # def parse(self, response): # pass # 爬虫启动时，会自动调用start_requests方法，并且只会被调用一次用于生成初始的Request对象 # 这个函数实现翻页功能，对每个url发起请求并调用parse方法进行处理 def start_requests(self): for i in range(0, 10): url = f'https://movie.douban.com/top250?start={i*25}' yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): items = [] soup = BeautifulSoup(response.text, 'html.parser') title_list = soup.find_all('div', attrs={'class', 'hd'}) for i in range(len(title_list)): item = DouBanMovieItem() title = title_list[i].find('a').find('span',).text link = title_list[i].get('href') item['title'] = title item['link'] = link items.append(item) # 返回items 而不是存储数据，交给pipline处理，解耦 return items items.py12345678910111213141516171819# Define here the models for your scraped items## See documentation in:# https://docs.scrapy.org/en/latest/topics/items.htmlimport scrapy# class SpidersItem(scrapy.Item):# # define the fields for your item here like:# # name = scrapy.Field()# pas# 定义一个item类，用于存储数据class DouBanMovieItem(scrapy.Item): # scrapy.Field() 定义一个字段，用于存储数据 类似于 Python 中的字典 title = scrapy.Field() link = scrapy.Field() 添加爬取页面详细信息movie.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 这里同样引用了pipline midedlewares等import scrapyfrom bs4 import BeautifulSoupfrom spiders.items import DouBanMovieItem class MoviesSpider(scrapy.Spider): name = &quot;movies&quot; # 爬虫名称 运行时候很重要 allowed_domains = [&quot;movie.douban.com&quot;] # 允许爬取的域名，防止无限爬取 start_urls = [&quot;https://movie.douban.com/top250&quot;] # 第一次发起的请求，获取一部分头部信息等 # 注释默认的parse方法，重写parse方法 # def parse(self, response): # pass # 爬虫启动时，会自动调用start_requests方法，并且只会被调用一次用于生成初始的Request对象 # 这个函数实现翻页功能，对每个url发起请求并调用parse方法进行处理 def start_requests(self): for i in range(0, 3): url = f'https://movie.douban.com/top250?start={i*25}' yield scrapy.Request(url=url, callback=self.parse1) def parse1(self, response): items = [] soup = BeautifulSoup(response.text, 'html.parser') title_list = soup.find_all('div', attrs={'class', 'hd'}) for i in title_list: item = DouBanMovieItem() title = i.find('a').find('span',).text link = i.find('a').get('href') item['title'] = title item['link'] = link # 返回请求或者item对象交给engin, 由engin决定如何处理: # 1. 交给调度器入队列 # 2. 交给下载器下载 # 3. 交给spider解析 # meta: dict[str, Any] | None = None ： 用于在请求之间传递参数 item，depth等等 yield scrapy.Request(url=link, meta={'item': item}, callback=self.parse2) # 解析具体页面 获取电影详细信息 def parse2(self, response): item = response.meta['item'] soup = BeautifulSoup(response.text, 'html.parser') content = soup.find('div', attrs={'class':'related-info'}).get_text().strip() item['detail'] = content yield item piplines.py12345678910111213141516171819202122232425262728293031# Define your item pipelines here## Don't forget to add your pipeline to the ITEM_PIPELINES setting# See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html# useful for handling different item types with a single interfacefrom itemadapter import ItemAdapterimport osclass SpidersPipeline: # def process_item(self, item, spider): # return item # 每一个item管道组件都会调用process_item方法，并且必须返回一个item对象 def process_item(self, item, spider): # 打印当前工作目录 print(f&quot;-----------------------当前工作目录: {os.getcwd()}&quot;) # 打印文件保存路径 file_path = os.path.join(os.getcwd(), 'movies.csv') print(f&quot;-----------------------文件将保存在: {file_path}&quot;) title = item['title'] link = item['link'] detail = item['detail'] output = f'|{title}|\\t|{link}|\\t|{detail}|\\n\\n' with open(file_path, 'a+', encoding='utf-8') as f: f.write(output) return item 第二次爬取时候遇到了(302) 重定向，需要加入反爬虫机制 自定义中间件&amp;随机代理IP Downloader Middleware：The downloader middleware is a framework of hooks into Scrapy’s request/response processing. It’s a light, low-level system for globally altering Scrapy’s requests and responses. 遇到问题&amp;解决方案网站中的重定向30X 修改下User-Agnet,，尝试使用本地真实UserAgnet 查看start_requests()和parse()函数，在parse()函数中输出self.logger.info进行debug Ajax动态加载网页处理时候选择右键查看源码与控制台HTML不同的情况","link":"/2025/04/13/Python%E5%AD%A6%E4%B9%A0/"},{"title":"Way to 云南","text":"Day0下午六点坐飞机晚上八点半左右到了昆明。第一次坐飞机体验到了20分钟从白天到黑夜的全过程。到了酒店之后来了份过桥米线，吃个新鲜，这边的米线需要自己都动手下菜，先荤后素最后米线。吃的时候也是按照这个顺序最后喝鸡汤。夜晚漫步在这个城市给我一种回到了商丘的感觉，没有钢筋水泥高楼大厦，常见平房商铺 Day1上午翠湖公园，公园里只有大爷大妈再跳广场舞，公园外围有零星跑者 接着跑到讲武堂，没什么特色和武汉讲武堂内部结构相似 中午的火锅菌汤，外加牦牛肉，火锅底加上菌类巨鲜 下午的滇池半日游，可惜滇池是个户，在湖边看湖水还是很浑浊，吹吹风倒也不错。还体验了做缆车到一个山上，具体山名忘记了🤣，没往爬直奔昆明老街吃饭 晚上电动车狂飞到云南大学，预约满了没进去 Day2上午计划游玩官渡古镇和云南省博物馆。官渡古镇商业化挺严重，里面大部分是娱乐购物商铺 云南省博物馆和官渡古镇十分接近，步行15mins就到了，正巧是高考第一天，见到了许多考生和家长 中午吃了顿傣味手抓饭，不是很合胃口，偏辣 下午来到大理，第一次买站票 Day3大理第一天，作为旅游城市，大理环境宜人，在城镇公路边几乎见不到垃圾。上午闲逛了大理古城，商业化的同时保留了部分特色比如城里的古道，早晨的菜市场 下午从古镇（那个古镇忘记了）步行到洱海生态廊道。只用15元租辆共享单车即可享受洱海风景。在云南感觉触手就能碰到云朵。 Day4苍山索道+极限爬1111级台阶 Day5在民宿呆了半天，晚上🚝大理-昆明，✈昆明-武汉。准备当天的毕业合照。 遗珠之憾在昆明旅行时候接到了拍毕业合照的通知，打乱了我们的旅行计划。原本打算的香格里拉还没有去，心中的日月成为遗珠之憾，还会再回来的。","link":"/2024/06/30/Way%20to%20%E4%BA%91%E5%8D%97/"},{"title":"clash+VmWareNat模式代理","text":"背景windows 11 使用VMware开ubunt虚拟机由于本地使用clash代理，虚拟机无法正常使用网络。 解决方案-NAT模式这通常是因为虚拟机的网络配置没有正确地指向主机的代理服务。解决思路是：将虚拟机的网络模式设置为NAT，然后在ubunt系统内部手动配置代理指向本地。 基础网络设置与检查关闭虚拟机还原 VMware 虚拟网络默认设置（可选） VMware 中点击“编辑” -&gt; “虚拟网络编辑器”-&gt;“还原默认设置” 查看“NAT设施”和“DHCP设置”，（如果不清楚子网IP，NAT，DHCP怎么设置建议直接按照下图填写） 配置主机代理以允许虚拟机访问确保主机上的代理软件（Clash-verge）允许来自虚拟机的连接，并获取必要的IP和端口信息。 允许来自局域网的连接 “clash-verge”-&gt;“局域网连接”和“端口设置”（以7890为例） 获取主机的 VMnet8 IP 地址 “本地cmd”-&gt;“ipconfig”-&gt;VMnet8 IP 地址 获取代理端口号 “7890“ 配置 Ubuntu 虚拟机代理设置虚拟机网络配饰器为NAT模式 VMware中进入“虚拟机”-&gt;“设置”-&gt;“网络适配器” “网络适配器”-&gt;“自定义:特定虚拟网络”-&gt;“VMnet8” 启动 Ubuntu 虚拟机打开网络代理设置 进入 Ubuntu 的“设置” (Settings)。 选择“网络” (Network)。 找到“网络代理” (Network Proxy) 选项，点击进入设置 选择“手动” (Manual) 代理配置 在 HTTP 代理和 HTTPS 代理（或者 SOCKS 代理，取决于你主机代理的类型）的地址栏中，填入上一步获取的主机 VMnet8 的 IP 地址和主机代理软件的端口号 保存设置并重启network 不足之处 本地机器开机时候IP地址会改变，需要手动填写一遍 网上有人说使用clash的TUN模式比较方便，我在开启后仍然无法使用本地代理","link":"/2025/05/26/clash-VmWareNat%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%90%86/"},{"title":"clash-verge+vmare主机代理","text":"转载自https://blog.csdn.net/weixin_63594197/article/details/138069939 一、前言关于这样的教程其实网上的教程有很多，笔者也看过这些教程，但是大多都有问题，最主要的问题是：****当主机ip变化的时候，需要重新配置代理ip.****因此笔者写此文章，记录一下，以便给其他人做参考。 【2024-12-29补充】如果主机是使用代理软件走代理的话，比如clash， 可以直接使用Tun模式。Tun模式下，代理软件会创建一个虚拟网卡，主机上的进程（包括虚拟机）的网络请求都会重定向到这个虚拟网卡。这种模式拦截了所有进程的网络请求，有些进程并不遵守系统代理，比如终端, pip, docker等等，Tun模式专治这种。 章节查阅： 使用系统代理模式，参考 第二章-第七章，以前文章是这种模式，只要配置了http_proxy这类的环境变量，进程可能就会按照环境配置使用代理 使用Tun模式， 参考第八章 系统代理模式与Tun模式区别 参考第八章 推荐使用Tun模式 二、配置的大致过程 VM软件配置 主机配置 Vm虚拟机配置 以上过程基本不需要敲命令。 三、VM软件配置1.VM虚拟网络编辑器打开虚拟网络编辑器（方式：编辑-&gt;虚拟网络编辑器), 然后点击更改设置 2.配置VMnet8和VMnet1VMnet8【子网配置】如下： 【NAT设置】如下： 【DHCP设置】如下：（可以理解为虚拟机的ip范围， 不要跟上图配置的网关冲突了） 【VMnet1】采用默认配置就可以了，当然你也可以按照上述vmnet8的方式修改一个容易记住的ip： 四、主机IP配置windows进入打开设置-&gt;网络 【2024-9-18补充】【可选START // 表示这个这个范围是可有可无的】 双击上述红框，然后配置如下：（这里不要跟之前的网关冲突了） 【2024-9-18补充】【可选END // 表示这个范围是可有可无的】 代理软件要开启【Allow LAN】：（这里要记住端口, 我的是7890） 然击后点： 记住下面的接口ip,这个ip需要在Vm虚拟机中使用， 两个都可以用 在windows终端下输入ipconfig同样可以查到： 五、虚拟机代理ip配置在配置代理之前需要设置网络适配器， 我们之前配置了VMnet8，在这里可以使用。 5.1 虚拟机上用【设置】配置代理用【设置】配置代理，代理设置会影响所有图形app， 比如浏览器，shell.. 但是却影响不了ssh(用ssh连接虚拟机ubuntu)终端，所以在使用ssh还需要配置代理，参考第七节。 当然这种配置也影响不了很多需要单独配置代理的app, 比如conda, pip, docker等等 进入虚拟机，配置ip,如果是Ubuntu可以参考下面的配置：(注意下图的端口，要跟代理软件的端口一致) 然后可以打开浏览器看外网，或者终端： 六、关于代理ip的选择问题【2024-9-18补充 START】 按照以上，我们得到了两组代理ip: VMnet1: 192.168.80.1 VMnet8: 192.168.6.1 用虚拟机ping 上述ip（比如 ping 192.168.80.1）, 能ping通就说明虚拟机与主机处于同一局域网下。 笔者的实际情况：笔者上述ip在虚拟机下均可ping通，按道理来说都可以使用的，但在实际情况中，VMnet1能用，VMnet8不能用。 这块笔者并没有了解VM网络背后原理，稀里糊涂就过去了，反正能用就行了^_^。 【2024-9-18补充 END】 之前的配置中，我使用的是VMnet1的网络接口，而不是VMnet8的？ 这主要是我发现VMnet8的网络接口发现没有用，这时尝试使用VMnet1发现可以使用代理了. 七、关于ssh代理配置，终端使用代理ssh连接 1. vscode proxy配置这样就可以使用一些需要代理的插件，比如copilot 2. ssh远程终端使用代理在~/.bashrc中添加代理配置: 12345678910111213141516171819202122# 代理export hostip=192.168.80.1export post=7890alias proxy=' export http_proxy=http://${hostip}:${post} export https_proxy=http://${hostip}:${post} export ALL_PROXY=http://${hostip}:${post} export all_proxy=socks://${hostip}:${post}'alias unproxy=' unset ALL_PROXY unset https_proxy unset http_proxy unset all_proxy'alias echoproxy=' echo $ALL_PROXY echo $all_proxy echo $https_proxy echo $http_proxy' source ~/.bashrc 想要使用代理了，终端输入proxy,取消unproxy。 八、【2024-12-29补充】Tun模式\\1. 需要主机代理软件支持Tun模式 \\2. 【2024-12-29笔者推荐使用clash-verge-rev】Release Clash Verge Rev v2.0.2 · clash-verge-rev/clash-verge-rev · GitHub \\3. 官方教程文档：快速入门 - Clash Verge Rev Docs \\4. 系统代理和Tun模式区别，截图自上述教程文档：","link":"/2025/05/25/clash-verge-vmare%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/"},{"title":"&lt;你想活出怎样的人生&gt;观后感","text":"0.引言随着宫崎骏最后一部作品《你想活出怎样的人生》在影院上映，最近和朋友一起去看了这部电影。我对宫崎骏大师的作品没有谈得上特别喜爱也也算不上讨厌，只是记得小时候第一次看《千与千寻》时对电影中的画风有一丝不适应，但看的多了也慢慢习惯长惊讶于宫崎骏大师天马行空的想象力和剧情中所隐喻的道理。 1. 看完后的不知所措整部电影讲述的是主人公真人的母亲祸害丧生，随父亲和自己小姨（母亲的妹妹）组成新家庭。随着苍鹭的引导进入奇幻世界冒险故事。 宫崎骏大师和吉卜力工作室的制作水准一如既往的优秀，电影画面随意截一帧都可以当作壁纸。然而如此优秀的动画水准剧情很是奇怪。看完整部电影之后我只能从剧情中提到的战争，鹦鹉国王等细节之处感受到电影可能是讲的反战题材。这种细节少之又少，在我看来一部值得人们反思的电影应该是话说三分留七分供观众思考那么《你想活出怎样的人生》话只说了一份，九分让观众思考。 看完之后忽略掉反战的部分我甚至觉得可以改为《寻妈历险记》。 2. 献给自己的告别之作出影院之后我查了下这部电影的相关资料。电影中的剧情和主人公可以说是宫崎骏老爷子的真实写照。伴随着二战战火成长以及战后对战争的反思出现在老爷子的许多作品之中。在我来，在观众看来一些离奇的剧情和人物在宫崎骏老爷子心中总有真是的生活写照。","link":"/2024/04/06/%E4%BD%A0%E6%83%B3%E6%B4%BB%E5%87%BA%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BA%BA%E7%94%9F-%E8%A7%82%E5%90%8E%E6%84%9F/"}],"tags":[{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Journey","slug":"Journey","link":"/tags/Journey/"}],"categories":[{"name":"生活碎片","slug":"生活碎片","link":"/categories/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87/"}],"pages":[]}